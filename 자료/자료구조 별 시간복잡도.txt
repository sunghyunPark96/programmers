배열 (Array):
접근: O(1)
삽입 (중간/끝): O(n)
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 데이터를 순차적으로 관리하며 빠른 접근이 필요한 경우. 메모리 할당은 한 번에 이루어집니다.

벡터 (Vector):
접근: O(1)
삽입 (중간/끝): O(n)
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 동적 배열로 크기 조절이 가능한 상황에서 사용됩니다. 배열의 크기가 필요에 따라 늘어날 수 있습니다.

연결 리스트 (Linked List):
접근: O(n)
삽입 (중간/끝): O(1)
검색: O(n)
정렬: O(n^2) ~ O(n log n) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 삽입과 삭제가 빈번한 경우에 사용됩니다. 메모리 할당은 각 노드마다 이루어집니다.

스택 (Stack):
접근: O(n)
삽입 (맨 위): O(1)
검색: O(n)
정렬: 스택 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 후입선출(LIFO) 구조로 사용되며, 함수 호출 스택, 괄호 검사 등에 활용됩니다.

큐 (Queue):
접근: O(n)
삽입 (맨 앞/뒤): O(1)
검색: O(n)
정렬: 큐 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 선입선출(FIFO) 구조로 사용되며, 태스크 큐, 프린터 대기열 등에 활용됩니다.

ordered map:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 키와 값의 쌍을 저장하며, 키 기반의 검색이 필요한 경우.

unordered map:
접근: O(1) ~ O(n) (해시 충돌에 따라 다름)
삽입: O(1) ~ O(n) (해시 충돌에 따라 다름)
검색: O(1) ~ O(n) (해시 충돌에 따라 다름)
정렬: 내부적으로 정렬하지 않음
공간 복잡도: O(n)
주로 사용되는 곳: 빠른 키 기반의 검색이 필요한 경우.

set:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 중복되지 않는 값들을 저장하며, 키 기반의 검색이 필요한 경우.
