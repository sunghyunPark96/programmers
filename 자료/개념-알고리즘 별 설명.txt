재귀
---------------------------------------------
- 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
- 재귀 함수 : 자기 자신을 다시 호출하는 순환 함수
- 기저조건 : 재귀함수에서 재귀를 종료하기 위한 조건
- 재귀호출 : 자기자신을 다시 호출하는 부분으로 재귀를 반복하다보면 반드시 기저조건으로 수렴(무한loop회피)





정렬
---------------------------------------------
1. 퀵 정렬 (Quick Sort):
시간 복잡도: 평균 O(n log n), 최악 O(n^2)
주로 사용되는 곳: 대부분의 일반적인 정렬 작업에 사용됩니다. 빠른 평균 실행 시간을 가지고 있으며, 효율적인 기능을 제공합니다.
사용하는 자료구조: 주로 배열이나 벡터와 같은 순차 데이터 구조를 사용합니다.

2. 병합 정렬 (Merge Sort):
시간 복잡도: O(n log n)
주로 사용되는 곳: 안정적인 정렬이 필요한 경우에 사용됩니다. 대규모 데이터셋에도 효과적이며, 연결 리스트와 같은 링크 구조에도 적용 가능합니다.
사용하는 자료구조: 주로 배열이나 연결 리스트와 같은 데이터 구조를 사용합니다.

3. 힙 정렬 (Heap Sort):
시간 복잡도: O(n log n)
주로 사용되는 곳: 최댓값 또는 최솟값 검색이 필요한 경우나, 내림차순으로 정렬이 필요한 상황에 사용됩니다. 우선순위 큐를 구현하는데 사용할 수 있습니다.
사용하는 자료구조: 배열과 힙 구조를 사용합니다. 주로 최대 힙을 활용합니다.

4. STL의 std::sort:
시간 복잡도: 일반적으로 O(n log n)
주로 사용되는 곳: 기본적인 정렬 작업에 사용됩니다. C++ 표준 라이브러리의 일부로 제공되며, 내부적으로는 퀵 정렬 또는 다른 효율적인 알고리즘을 사용합니다.
사용하는 자료구조: 주로 배열, 벡터, 리스트 등의 데이터 구조를 사용합니다.
위의 설명을 통해 각 정렬 알고리즘의 시간 복잡도, 주로 사용되는 상황, 그리고 사용되는 자료구조를 이해하실 수 있을 것입니다. 선택한 알고리즘이 문제와 데이터의 특성에 맞는지 고려하여 사용하시면 됩니다.

값 탐색
-----------------------------------------------
1. 선형 탐색 (Linear Search):
시간 복잡도: O(n)
주로 사용되는 곳: 정렬되지 않은 배열 또는 리스트에서 특정 값을 찾을 때 사용됩니다. 데이터가 작을 때나 특정 데이터 위치를 모를 때 유용합니다.
사용하는 자료구조: 배열, 리스트 등 순차 데이터 구조를 사용합니다.

2. 이진 탐색 (Binary Search):
시간 복잡도: O(log n)
주로 사용되는 곳: 정렬된 배열 또는 리스트에서 특정 값을 빠르게 찾을 때 사용됩니다. 데이터가 정렬되어 있어야 하며, 데이터가 큰 경우에 유용합니다.
사용하는 자료구조: 배열, 리스트 등 순차 데이터 구조를 사용합니다.

3. 해시 테이블 (Hash Table)
시간 복잡도: 일반적으로 O(1) (최악의 경우에도 O(n))
주로 사용되는 곳: 빠른 검색 속도가 필요한 경우, 중복을 허용하지 않는 데이터 저장이 필요한 경우 등에 사용됩니다.
사용하는 자료구조: 해시 테이블로 데이터를 저장하고 검색합니다.

4. 깊이 우선 탐색 (DFS - Depth-First Search):
시간 복잡도: O(V + E) (V는 정점 수, E는 간선 수)
주로 사용되는 곳: 그래프의 구조 파악, 연결 요소 찾기, 사이클 검사, 백트래킹 등에 사용됩니다.
사용하는 자료구조: 재귀 함수나 스택을 사용하여 구현합니다.

5. 너비 우선 탐색 (BFS - Breadth-First Search):
시간 복잡도: O(V + E) (V는 정점 수, E는 간선 수)
주로 사용되는 곳: 최단 경로 탐색, 네트워크 분석, 그래프의 레벨 구분 등에 사용됩니다.
사용하는 자료구조: 큐를 사용하여 구현합니다.


