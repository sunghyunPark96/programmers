배열 (Array):
- 같은 종류의 데이터가 연속적으로 저장되어 있는 자료 구조
- 캐시 지역성 : 배열의 각 원소가 서로 인접한 메모리 주소를 가지기 때문에 하나의 원소에 접근 시 근방에 있는 원소도 함께 캐시(cpu버퍼에 저장되는 데이터)로 가져오기 때문에 반복문에서 효율적.
2차 어레이를 선언하고 for문을 실행할 때 row의 마지막 원소에 접근할 때 다음 row의 첫번째 원소 메모리주소를 캐시로 가져오기 때문에 row 먼저 돌고, column을 도는게 효율적.
- 크기 불변
- 스택 메모리 영역(보통1MB)에 할당되기 때문에 큰 크기의 배열을 선언할 시 메모리 영역을 초과하는 스택오버플로우 발생 가능.
- 선언 예시 : 1D(array<int,5> x {1,2,3,4,5};), 2D(array<array<int,2>,2> x {{1,2},{3,4}};)
- 삽입, 삭제 시 현재 메모리에 할당된 데이터들을 전체 복사 한뒤 우로 밀착, 좌로 믹착 하는 형태이기 때문에 시간복잡도 O(n) 
접근: O(1)
삽입: (중간/끝): O(n)
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 데이터를 순차적으로 관리하며 빠른 접근이 필요한 경우. 메모리 할당은 한 번에 이루어집니다.

벡터 (Vector):
- 배열의 크기 불변 특징을 극복한 자료구조로 포인터를 활용한 메모리의 동적할당을 통해 배열의 크기를 확장 시킬 수 있음.
- 벡터 객체 별로 멤버변수(capacity, length, 포인터)는 지역변수로 취급되어 스택에 저장되고 실제 데이터들은 힙 메모리 영역에 할당 되기 때문에 큰 크기의 벡터를 선언가능하지만 스택에 비해 느림.
- stl에서 제공하는 std:vector의 경우 동적할당된 메모리를 자동으로 new, del하기 때문에 메모리 해제를 수동으로할 필요는 없음.
- 선언 예시 : vector<int> x {1,2,3,4,5};, vector<vector<int>> x {{1,2},{3,4}};
접근: O(1)
삽입: push_back() : O(1), insert() : O(n)
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 동적 배열로 크기 조절이 가능한 상황에서 사용됩니다. 배열의 크기가 필요에 따라 늘어날 수 있습니다.

연결 리스트 (Linked List):
- 헤드로 시작할 주소를 가르키고 데이터(정수,문자열,복합 자료형)와 링크(다음이나 전 노드를 가르키는 포인터)로 구성된 노드가 앞 뒤로 연결되어 있는 자료구조로배열처럼 원소들이 순서대로
메모리를 점유하는 것이 아니라 산재되어 있음.
- 삽입의 시간복잡도가 O(1)이기 때문에 삽입할 것이 많은 경우 사용
- 단순 연결 리스트, 이중 연결 리스트(header, tailer 존재), 원형 연결 리스트 존재
- 1,2,3 순서로 값이 저장되어있을 때 3을 호출 하고 싶으면 head-1-2-3을 거쳐가야 되기 때문에 접근이 비효율적임.
- 연결리스트도 동적 할당이 가능하기 때문에 데이터들이 힙영역에 선언됨
- .splice() 사용하여 리스트 두개 합칠 때 l2.splice(l2.end(),l1)으로 합치되 l1은 복사가 아닌 비워지는 리스트로 변경
- std의 sort함수가 적용이 안되기 때문에 list의 멤버 함수인 .sort()를 활용
- 양방향 리스트 선언 예시 : list<int> x {1,2,3};
- 단방향 리스트 선언 예시 : forward_list<> x {1,2,3};
접근: O(n)
삽입 (중간/끝): O(1)
검색: O(n)
정렬: O(n^2) ~ O(n log n) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 삽입과 삭제가 빈번한 경우에 사용됩니다. 메모리 할당은 각 노드마다 이루어집니다.

스택 (Stack):
접근: O(n)
삽입 (맨 위): O(1)
검색: O(n)
정렬: 스택 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 후입선출(LIFO) 구조로 사용되며, 함수 호출 스택, 괄호 검사 등에 활용됩니다.

큐 (Queue):
접근: O(n)
삽입 (맨 앞/뒤): O(1)
검색: O(n)
정렬: 큐 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 선입선출(FIFO) 구조로 사용되며, 태스크 큐, 프린터 대기열 등에 활용됩니다.

ordered map:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 키와 값의 쌍을 저장하며, 키 기반의 검색이 필요한 경우.

unordered map:
접근: O(1) ~ O(n) (해시 충돌에 따라 다름)
삽입: O(1) ~ O(n) (해시 충돌에 따라 다름)
검색: O(1) ~ O(n) (해시 충돌에 따라 다름)
정렬: 내부적으로 정렬하지 않음
공간 복잡도: O(n)
주로 사용되는 곳: 빠른 키 기반의 검색이 필요한 경우.

set:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 중복되지 않는 값들을 저장하며, 키 기반의 검색이 필요한 경우.
