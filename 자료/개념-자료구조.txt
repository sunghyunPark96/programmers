Sequence Container - 배열 (Array):
- 같은 종류의 데이터가 연속적으로 저장되어 있는 자료 구조
- 캐시 지역성 : 배열의 각 원소가 서로 인접한 메모리 주소를 가지기 때문에 하나의 원소에 접근 시 근방에 있는 원소도 함께 캐시(cpu버퍼에 저장되는 데이터)로 가져오기 때문에 반복문에서 효율적.
2차 어레이를 선언하고 for문을 실행할 때 row의 마지막 원소에 접근할 때 다음 row의 첫번째 원소 메모리주소를 캐시로 가져오기 때문에 row 먼저 돌고, column을 도는게 효율적.
- 크기 불변
- 스택 메모리 영역(보통1MB)에 할당되기 때문에 큰 크기의 배열을 선언할 시 메모리 영역을 초과하는 스택오버플로우 발생 가능.
- 선언 예시 : 1D(array<int,5> x {1,2,3,4,5};), 2D(array<array<int,2>,2> x {{1,2},{3,4}};)
- 삽입, 삭제 시 현재 메모리에 할당된 데이터들을 전체 복사 한뒤 우로 밀착, 좌로 믹착 하는 형태이기 때문에 시간복잡도 O(n) 
인덱스 접근: O(1) --> Random Access가 인덱스 존재해서 가능
삽입: (처음/중간): O(n), (끝) O(1) --> 처음/중간에 삽입할 경우 전체 메모리를 복사해서 다음칸에 밀어 넣어야 되서 느림
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 데이터를 순차적으로 관리하며 빠른 접근이 필요한 경우. 메모리 할당은 한 번에 이루어집니다.

Sequence Container - 벡터 (Vector):
- 배열의 크기 불변 특징을 극복한 자료구조로 포인터를 활용한 메모리의 동적할당을 통해 배열의 크기를 확장 시킬 수 있음.
- 벡터 객체 별로 멤버변수(capacity, length, 포인터)는 지역변수로 취급되어 스택에 저장되고 실제 데이터들은 힙 메모리 영역에 할당 되기 때문에 큰 크기의 벡터를 선언가능하지만 스택에 비해 느림.
- stl에서 제공하는 std:vector의 경우 동적할당된 메모리를 자동으로 new, del하기 때문에 메모리 해제를 수동으로할 필요는 없음.
- 선언 예시 : vector<int> x {1,2,3,4,5};, vector<vector<int>> x {{1,2},{3,4}};
인덱스 접근: O(1) --> Random Access가 인덱스 존재해서 가능
삽입: (처음/중간): O(n), (끝) O(1) --> 처음/중간에 삽입할 경우 전체 메모리를 복사해서 다음칸에 밀어 넣어야 되서 느림
검색: O(n)
정렬: O(n log n) ~ O(n^2) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 동적 배열로 크기 조절이 가능한 상황에서 사용됩니다. 배열의 크기가 필요에 따라 늘어날 수 있습니다.

Sequence Container - 연결 리스트 (Linked List):
- 헤드로 시작할 주소를 가르키고 데이터(정수,문자열,복합 자료형)와 링크(다음이나 전 노드를 가르키는 포인터)로 구성된 노드가 앞 뒤로 연결되어 있는 자료구조로배열처럼 원소들이 순서대로
메모리를 점유하는 것이 아니라 산재되어 있음.
- 삽입의 시간복잡도가 O(1)이기 때문에 삽입할 것이 많은 경우 사용
- 단순 연결 리스트, 이중 연결 리스트(header, tailer 존재), 원형 연결 리스트 존재
- 1,2,3 순서로 값이 저장되어있을 때 3을 호출 하고 싶으면 head-1-2-3을 거쳐가야 되기 때문에 접근이 비효율적임.
- 연결리스트도 동적 할당이 가능하기 때문에 데이터들이 힙영역에 선언됨
- .splice() 사용하여 리스트 두개 합칠 때 l2.splice(l2.end(),l1)으로 합치되 l1은 복사가 아닌 비워지는 리스트로 변경
- std의 sort함수가 적용이 안되기 때문에 list의 멤버 함수인 .sort()를 활용
- 양방향 리스트 선언 예시 : list<int> x {1,2,3};
- 단방향 리스트 선언 예시 : forward_list<> x {1,2,3};
인덱스 접근: O(n) --> Random Access가 인덱스 없어서 불가능
삽입 (처음/중간/끝): O(1) --> 각 노드가 포인터로 연결되어 있어서 삽입 시 노드 사이에 새로운 노드만 만들면 되서 빠름
검색: O(n)
정렬: O(n^2) ~ O(n log n) (알고리즘에 따라 다름)
공간 복잡도: O(n)
주로 사용되는 곳: 삽입과 삭제가 빈번한 경우에 사용됩니다. 메모리 할당은 각 노드마다 이루어집니다.

Container Adaptors - 스택 (Stack):
- 데이터를 쌓아 올리듯이 저장하는 선형 자료 구조로써 후입선출(LIFO) 원리에 따라 삽입과 삭제가 수행됨
- 컨데이너로 배열, 디큐, 연결리스트사용 컨테이너 특징을 그대로 따라감
- 구현이 간단하고 삽입이나 삭제가 빠르게 동작
- 정해진 크기를 초과할경우 스택오버플로우 발생 가능
- 스택 선언 예시
1) 디폴트인 deque로 스택구현
stack<int> x;
x.push(10);
x.push(20);
x.push(30);
x.pop(); --> 30
인덱스 접근: O(n) --> Random Access가 인덱스 없어서 불가능
삽입 (맨 위): O(1)
검색: O(n)
정렬: 스택 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 후입선출(LIFO) 구조로 사용되며, 함수 호출 스택, 괄호 검사 등에 활용됩니다. (뒤로가기, 편집기의 CTRL+Z 기능에 활용)

Container Adaptors - 큐 (Queue):
- 줄을 세우 듯이 저장하는 선형 자료 구조로써 선입선출(FIFO) 원리에 따라 삽입과 삭제가 수행
- 컨데이너로 디큐, 연결리스트사용 컨테이너 특징을 그대로 따라감
- push로 입력(last in), pop으로 출력(first out)
- 큐 선언 예시
queue<int> x;
x.push(10);
x.push(20);
x.push(30);
x.pop(); --> 10
접근: O(n)
삽입 (맨 앞/뒤): O(1)
검색: O(n)
정렬: 큐 자체는 정렬 기능 없음
공간 복잡도: O(n)
주로 사용되는 곳: 선입선출(FIFO) 구조로 사용되며, 태스크 큐, 프린터 대기열 등에 활용됩니다.

Container Adaptors - 환형 큐 (Queue):
- push는 메모리 공간 상 가장 뒤에 추가 되고 pop은 메모리 공간 상 가장 앞에서 제거 되기 때문에 push, pop이 반복 될경우 앞 쪽의 메모리 공간이
의미 없이 공간을 차지 하게 되는 문제점(rightward drift)을 개선한 큐=환형큐
- 환형 큐는 선입선출(FIFO)의 원칙에 따라 작업이 수행되고 마지막 위치가 원을 이루듯이 다시 첫 번째 위치에 연결되는 선형 데이터 구조
- 데이터가 추가될 경우 첫번 째 데이터칸(front) 시계방향으로 한칸 전진, 제거될 경우 마지막 데이터칸(rear) 시계방향으로 한칸 전진
Associative Containers - ordered map:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 키와 값의 쌍을 저장하며, 키 기반의 검색이 필요한 경우.

Associative Containers - unordered map:
접근: O(1) ~ O(n) (해시 충돌에 따라 다름)
삽입: O(1) ~ O(n) (해시 충돌에 따라 다름)
검색: O(1) ~ O(n) (해시 충돌에 따라 다름)
정렬: 내부적으로 정렬하지 않음
공간 복잡도: O(n)
주로 사용되는 곳: 빠른 키 기반의 검색이 필요한 경우.

Associative Containers - set:
접근: O(log n)
삽입: O(log n)
검색: O(log n)
정렬: 내부적으로 정렬된 상태 유지
공간 복잡도: O(n)
주로 사용되는 곳: 중복되지 않는 값들을 저장하며, 키 기반의 검색이 필요한 경우.

* 선형 자료구조 : 일자로 진행되는 자료 구조 (배열, 벡터, 연결리스트, 큐, 스택)
